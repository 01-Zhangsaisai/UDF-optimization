# Оптимизация функции возврата списка заказов

## Описание задачи

Цель данного задания — оптимизировать запрос для получения списка заказов с целью повышения производительности. Запрос должен работать быстро при большом объеме данных (например, 50 000 заказов с 3 элементами в каждом). Основной запрос, который нуждается в оптимизации:

```sql
select top 3000 * from dbo.F_WORKS_LIST();
``` 
## Задача 1: Анализ скрипта функции и выявление проблем с производительностью
При анализе функции F_WORKS_LIST были выявлены следующие потенциальные проблемы:

Множество вызовов пользовательских функций:
Функции, такие как F_WORKITEMS_COUNT_BY_ID_WORK и F_EMPLOYEE_FULLNAME, вызываются для каждой строки, что приводит к значительному снижению производительности, особенно при большом объеме данных.

Использование LEFT OUTER JOIN:
Запрос использует LEFT OUTER JOIN с таблицей WorkStatus. Это может стать проблемой, если таблицы большие, и нет подходящих индексов.

Отсутствие индексов:
Фильтрация по столбцам, таким как IS_DEL и StatusId, без наличия индексов может замедлить выполнение запроса.

Операция сортировки:
Использование ORDER BY без соответствующего индекса может замедлить выполнение запроса, особенно при большом количестве данных.

## Задача 2: Предложение оптимизаций
Для оптимизации производительности запроса мы предлагаем следующие изменения:

Использование CTE (Общие Таблицы Выражений):
Преобразуем запрос, чтобы уменьшить количество вызовов функций, предварительно вычислив необходимые данные с помощью CTE.

Добавление индексов:
Создадим индексы на столбцы, которые часто используются в фильтрации и соединении, такие как IS_DEL, StatusId, и id_work.

Пример оптимизированного запроса:

```sql
WITH WorkItemsCount AS (
    SELECT 
        id_work, 
        SUM(CASE WHEN is_complit = 0 THEN 1 ELSE 0 END) AS WorkItemsNotComplit,
        SUM(CASE WHEN is_complit = 1 THEN 1 ELSE 0 END) AS WorkItemsComplit
    FROM workitem
    GROUP BY id_work
),
EmployeeFullName AS (
    SELECT 
        id_employee, 
        SURNAME + ' ' + UPPER(SUBSTRING(NAME, 1, 1)) + '. ' +
        UPPER(SUBSTRING(PATRONYMIC, 1, 1)) + '.' AS FullName
    FROM Employee
)
SELECT 
    Works.Id_Work,
    Works.CREATE_Date,
    Works.MaterialNumber,
    Works.IS_Complit,
    Works.FIO,
    CONVERT(VARCHAR(10), Works.CREATE_Date, 104) AS D_DATE,
    COALESCE(WorkItemsCount.WorkItemsNotComplit, 0) AS WorkItemsNotComplit,
    COALESCE(WorkItemsCount.WorkItemsComplit, 0) AS WorkItemsComplit,
    COALESCE(EmployeeFullName.FullName, '') AS EmployeeFullName,
    Works.StatusId,
    WorkStatus.StatusName,
    CASE
        WHEN (Works.Print_Date IS NOT NULL) OR
             (Works.SendToClientDate IS NOT NULL) OR
             (Works.SendToDoctorDate IS NOT NULL) OR
             (Works.SendToOrgDate IS NOT NULL) OR
             (Works.SendToFax IS NOT NULL)
        THEN 1
        ELSE 0
    END AS Is_Print
FROM Works
LEFT JOIN WorkStatus ON Works.StatusId = WorkStatus.StatusID
LEFT JOIN WorkItemsCount ON Works.Id_Work = WorkItemsCount.id_work
LEFT JOIN EmployeeFullName ON Works.Id_Employee = EmployeeFullName.id_employee
WHERE Works.IS_DEL <> 1
ORDER BY Works.id_work DESC;
```

## Задача 3: Возможные изменения структуры БД

1.Создание индексов:
Для ускорения фильтрации и соединений, а также для улучшения производительности сортировки, рекомендуется создать индексы на столбцы IS_DEL, StatusId и id_work:

```sql
CREATE NONCLUSTERED INDEX idx_IS_DEL_StatusId ON Works (IS_DEL, StatusId);
CREATE NONCLUSTERED INDEX idx_id_work ON Works (id_work);
```

2.Использование триггеров или хранимых процедур:
При необходимости добавления новых функций для кэширования или вычислений следует учитывать возможные отрицательные последствия, такие как увеличение сложности поддержания данных.
